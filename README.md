#  Преобразование Фурье

## структура репы

- `cpp/` - реализация на плюсах
- `tests/` - примеры файлов с входным вектором (формат: первая строка - длина n вектора X, потом xi на i+1-й строке), и ожидаемые результаты(без n и в "читаемом" формате, т.е. 3+i, вместо какого-нибудь (3.0, 0.999999))
- `материалы/` - всякие pdf

### материалы

1. [статья](материалы/parallel_fft.pdf) от зубова
2. [rosetta code](https://rosettacode.org/wiki/Fast_Fourier_transform)
3. какие-то [формулы](https://srikarthiks.files.wordpress.com/2019/01/r-parallel-programming-in-c-with-mpi-and-openmp.pdf) возможно для отчета

### что в отчетик

вроде зубов говорил, что надо добавить данные об аппартном устройстве машины, на которой это всё запускалось (подробнее на первой зубовской паре рассказано, надо уточнить). Наверняка нужно также указать алгоритмическую сложность и всякие формулы про параллельность(что-то про закон амдала, мб)

какие-то [формулы](https://srikarthiks.files.wordpress.com/2019/01/r-parallel-programming-in-c-with-mpi-and-openmp.pdf) в начале

## DFT

если бы постановка было про вообще DFT, то выполнение было бы примерно такое:
1. считывается входной вектор X, который надо преобразовать, выясняется его длина n = |X|
2. вычисляется "первообразный n-й корень из единицы" wn. считается по формуле: wn = e^(-2pi/n) (или wn = cos(2pi/n)+i * sin(2pi/n)). тут n - длина X, а i - мнимая единица
3. вычисляется матрица A коэффициентов (на англ пространстве их называют twiddle coefficients) по следующей формуле: каждый элемент aij = wn^(i * j). 0-я строка и 0-й столбец при любом n будут заполнены единичками, т.к. степень 0
4. матрица A тупо умножается на X. Результат A * X = B - вектор соразмерный X, который 100% будет содержать коплексные числа, даже если X состоит не из комплексных

За счёт п.3 сложность O(n^2) - мультипликативных операций пропорционально количеству элементов в матрице (n * n)

### про алгоритмическую сложность оепраций над комплексными

видимо, число можно хранить в тригонометрической форме, т.е. в формуле wn = cos(2pi/n)+i * sin(2pi/n) не считать синус и косинус при получении числа, а хранить только 2pi/n в данном случае. Тогда возведение wn в степень i\cdot j будет просто умножением 2pi/n * i * j

## FFT
### быстре чем DFT, но еще не распараллелено

суть в том, чтобы не считать всю матрицу A из п.3(n^2 мультипликативных операций), а заюзать стратегию "divide-and-conquer". в реализации на rosetta code более наглядно: входной X делится пополам и вызывается та же функция от первой и второй половины и там опять делится.

Итого, теперь, чтобы посчитать один из n элементов выходного вектора, надо сделать не n, а log(n) вычислений. Отсюда и общая сложность (для вычисления всех n элементов выходного вектора) теперь O(nlog(n).

Для этого, видимо, придётся входной вектор произвольной длины подогнать нулями в конце до длины степени двойки.

## Parallel FFT

распараллеливание заключается в следующем: вычислить независящие друг от друга штуки одновременно в отдельных потоках. пункт 1 не паралелится(чтение / запись данных - боттленек для закона амдала). вычисление wn тоже не параллелится. а вот итеративный (не рекурсивный как на rosetta code к сожалению) вариант можно распараллелить.

в разделе Parallel FFT в статье от зубова указано, что параллельная реализация состоит из 3 "фаз":
1) перестановка элементов X так, чтобы сначала шли все элементы с чётными индексами, потом все элементы с нечётными индексами
2) умножения, сложения, вычитания (всего log(n)-log(p) операций - так написано, не пересчитывала)
3) последние log(p) операций и обратная перестановка индексов

Перестановка индексов: в той же статье указан способ перестановки - реверсировать бинарное представление индекса(1011(11 в десятичной) -> 1101(13 в десятичной)). Причем там важно, чтоб ведущих нулей было столько, чтоб всего битов было log(n - для X длиной 16, число 2 надо записывать не 10, а 0010, чтоб получить 0100(4 в десятичной), а не 1(1 в десяитчной). Именно такой способ разделения на четные нечетные индексы позволить также эффективно переставить индексы обратно в пункте 3.

нерешенный вопрос: как задать оптимальное количество потоков, зная длину входного вектора n? (допустим вектор уже подогнан до длины степени двойки)?
